using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
/// <summary>
/// Wanqi Chin
/// 818386160
/// This method was the hardest for me. I tried many many things including drawLine with animationclock, creating a storyboard, etc, however this was the only
/// logic that provided what I was looking for. I searched missile command c# and found that this was the most popular implementation of incoming missiles.
/// 
/// </summary>
namespace MissileCommandRun
{
    class IncomingMissiles
    {
        private Point start_point, end_point;
        private int ySpeed, xSpeed;
        private bool bottom;
        private int endHeight;
    
        public IncomingMissiles(int width, int height, int maxSpeed, Random rand)
        {
            endHeight = height - 100; //need this height to be less than the clientSize height to correctly find endpoint because my bitmaps are positioned higher
            end_point.X = start_point.X = rand.Next(2, (width)); //starts at a random x coordinate generated by random class 
            end_point.Y = end_point.Y = 76; //starts 76 pixels from the top
            ySpeed = maxSpeed; //speed as chosen by gameplay mode
            int rate = height / ySpeed; //time it takes to draw missile in y coordinates
            double r = Math.Atan(Math.Abs((double)(end_point.Y - start_point.X) / (double)(end_point.X - start_point.X)));
            xSpeed = rand.Next(-1 * (width-start_point.X)/rate, 1 + (width - start_point.X) / rate);// time interval it takes missile to traverse from start point to end point
        }

        public void Move(Graphics g)
        {
            if (!bottom) //draws until reaches bottom
            {
                
                end_point.X += xSpeed;
                end_point.Y += ySpeed;
                g.DrawLine(new Pen(Color.Turquoise, 2), start_point, end_point);
                if (end_point.Y >= endHeight)
                    bottom = true;
            }
        }

        public Point GetEndPoint()
        {
            return end_point;
        }

        
    }
}
    

